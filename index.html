<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <meta name="theme-color" content="#000000">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <title>hereish</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    html, body {
      height: 100%;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #000;
      color: #fff;
      overflow: hidden;
      -webkit-tap-highlight-color: transparent;
    }

    .container {
      height: 100%;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      padding: 24px;
      text-align: center;
    }

    .location-primary {
      font-size: clamp(2rem, 12vw, 5rem);
      font-weight: 700;
      line-height: 1.1;
      margin-bottom: 8px;
      max-width: 100%;
      word-wrap: break-word;
    }

    .location-secondary {
      font-size: clamp(1rem, 5vw, 1.5rem);
      font-weight: 400;
      opacity: 0.6;
      margin-bottom: 32px;
    }

    .status {
      font-size: 1rem;
      opacity: 0.4;
    }

    .actions {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      display: flex;
      gap: 1px;
      background: #222;
    }

    .action-btn {
      flex: 1;
      padding: 20px;
      background: #111;
      border: none;
      color: #fff;
      font-size: 0.875rem;
      font-weight: 500;
      cursor: pointer;
      transition: background 0.15s;
    }

    .action-btn:hover, .action-btn:active {
      background: #222;
    }

    .action-btn:disabled {
      opacity: 0.3;
      cursor: not-allowed;
    }

    /* Details panel */
    .details-panel {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      background: #111;
      border-radius: 16px 16px 0 0;
      transform: translateY(100%);
      transition: transform 0.3s ease-out;
      max-height: 70vh;
      overflow-y: auto;
    }

    .details-panel.open {
      transform: translateY(0);
    }

    .details-handle {
      width: 36px;
      height: 4px;
      background: #444;
      border-radius: 2px;
      margin: 12px auto;
    }

    .details-content {
      padding: 8px 24px 32px;
    }

    .detail-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 16px 0;
      border-bottom: 1px solid #222;
    }

    .detail-row:last-child {
      border-bottom: none;
    }

    .detail-label {
      font-size: 0.875rem;
      opacity: 0.5;
    }

    .detail-value {
      font-size: 1rem;
      font-weight: 500;
      text-align: right;
      max-width: 60%;
      word-break: break-word;
    }

    .detail-value.mono {
      font-family: 'SF Mono', Monaco, 'Courier New', monospace;
      font-size: 0.875rem;
    }

    .close-details {
      position: absolute;
      top: 8px;
      right: 16px;
      background: none;
      border: none;
      color: #fff;
      font-size: 1.5rem;
      cursor: pointer;
      opacity: 0.5;
      padding: 8px;
    }

    .overlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.5);
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s;
    }

    .overlay.open {
      opacity: 1;
      pointer-events: auto;
    }

    /* Loading state */
    .loading .location-primary::after {
      content: '';
      animation: dots 1.5s infinite;
    }

    @keyframes dots {
      0%, 20% { content: ''; }
      40% { content: '.'; }
      60% { content: '..'; }
      80%, 100% { content: '...'; }
    }

    /* Toast notification */
    .toast {
      position: fixed;
      bottom: 100px;
      left: 50%;
      transform: translateX(-50%) translateY(20px);
      background: #333;
      color: #fff;
      padding: 12px 24px;
      border-radius: 8px;
      font-size: 0.875rem;
      opacity: 0;
      transition: all 0.3s;
      pointer-events: none;
    }

    .toast.show {
      opacity: 1;
      transform: translateX(-50%) translateY(0);
    }

    /* Error state */
    .error .location-primary {
      font-size: clamp(1.25rem, 6vw, 2rem);
      opacity: 0.8;
    }
  </style>
</head>
<body>
  <div class="container" id="container">
    <div class="location-primary" id="primary">Finding you</div>
    <div class="location-secondary" id="secondary"></div>
    <div class="status" id="status">Requesting location...</div>
  </div>

  <div class="actions" id="actions" style="display: none;">
    <button class="action-btn" id="shareBtn">Share</button>
    <button class="action-btn" id="detailsBtn">Details</button>
    <button class="action-btn" id="refreshBtn">Refresh</button>
  </div>

  <div class="overlay" id="overlay"></div>

  <div class="details-panel" id="detailsPanel">
    <div class="details-handle"></div>
    <button class="close-details" id="closeDetails">&times;</button>
    <div class="details-content" id="detailsContent"></div>
  </div>

  <div class="toast" id="toast"></div>

  <script>
    const $ = id => document.getElementById(id);
    let locationData = null;

    // Show toast message
    function toast(msg) {
      const t = $('toast');
      t.textContent = msg;
      t.classList.add('show');
      setTimeout(() => t.classList.remove('show'), 2000);
    }

    // Get human-readable location from coordinates
    async function reverseGeocode(lat, lon) {
      const url = `https://nominatim.openstreetmap.org/reverse?lat=${lat}&lon=${lon}&format=json&addressdetails=1&zoom=18`;
      const res = await fetch(url, {
        headers: { 'User-Agent': 'hereish-app' }
      });
      if (!res.ok) throw new Error('Geocoding failed');
      return res.json();
    }

    // Extract the best "neighborhood" level name
    function extractPrimary(address) {
      // Priority order for primary display
      const priorities = [
        'neighbourhood',
        'suburb',
        'hamlet',
        'village',
        'town',
        'city_district',
        'district',
        'city',
        'municipality'
      ];

      for (const key of priorities) {
        if (address[key]) return address[key];
      }

      return address.city || address.county || 'Unknown area';
    }

    // Extract secondary info (city/region if different from primary)
    function extractSecondary(address, primary) {
      const parts = [];

      if (address.city && address.city !== primary) {
        parts.push(address.city);
      } else if (address.town && address.town !== primary) {
        parts.push(address.town);
      } else if (address.municipality && address.municipality !== primary) {
        parts.push(address.municipality);
      }

      if (address.state) {
        // Abbreviate common US states
        const stateAbbrev = {
          'California': 'CA', 'New York': 'NY', 'Texas': 'TX',
          'Florida': 'FL', 'Washington': 'WA', 'Oregon': 'OR',
          'Nevada': 'NV', 'Arizona': 'AZ', 'Colorado': 'CO'
        };
        parts.push(stateAbbrev[address.state] || address.state);
      }

      return parts.join(', ');
    }

    // Format coordinates nicely
    function formatCoords(lat, lon) {
      const latDir = lat >= 0 ? 'N' : 'S';
      const lonDir = lon >= 0 ? 'E' : 'W';
      return `${Math.abs(lat).toFixed(5)}° ${latDir}, ${Math.abs(lon).toFixed(5)}° ${lonDir}`;
    }

    // Generate a simple word-based location code (fun alternative to what3words)
    function generateWordCode(lat, lon) {
      const words = [
        'apple', 'baker', 'coral', 'delta', 'eagle', 'frost', 'grove', 'honey',
        'ivory', 'jade', 'kite', 'lemon', 'maple', 'north', 'olive', 'pearl',
        'quiet', 'river', 'stone', 'tiger', 'umbra', 'vivid', 'willow', 'xenon',
        'yellow', 'zebra', 'amber', 'blaze', 'cloud', 'drift', 'ember', 'flame'
      ];

      // Simple hash based on coordinates
      const hash = Math.abs(Math.floor((lat * 1000000 + lon * 1000000) % (words.length ** 3)));
      const w1 = words[hash % words.length];
      const w2 = words[Math.floor(hash / words.length) % words.length];
      const w3 = words[Math.floor(hash / (words.length ** 2)) % words.length];

      return `${w1}.${w2}.${w3}`;
    }

    // Build details panel content
    function buildDetails(data, lat, lon) {
      const address = data.address || {};
      const rows = [];

      // Full address
      if (data.display_name) {
        rows.push({ label: 'Full address', value: data.display_name });
      }

      // Street/Road
      if (address.road) {
        let street = address.road;
        if (address.house_number) street = `${address.house_number} ${street}`;
        rows.push({ label: 'Street', value: street });
      }

      // Neighborhood
      if (address.neighbourhood || address.suburb) {
        rows.push({ label: 'Neighborhood', value: address.neighbourhood || address.suburb });
      }

      // City
      if (address.city || address.town || address.municipality) {
        rows.push({ label: 'City', value: address.city || address.town || address.municipality });
      }

      // Postal code
      if (address.postcode) {
        rows.push({ label: 'Postal code', value: address.postcode });
      }

      // County
      if (address.county) {
        rows.push({ label: 'County', value: address.county });
      }

      // State
      if (address.state) {
        rows.push({ label: 'State', value: address.state });
      }

      // Country
      if (address.country) {
        rows.push({ label: 'Country', value: address.country });
      }

      // Coordinates
      rows.push({ label: 'Coordinates', value: formatCoords(lat, lon), mono: true });

      // Decimal coords (for copying)
      rows.push({ label: 'Lat, Lon', value: `${lat.toFixed(6)}, ${lon.toFixed(6)}`, mono: true });

      // Word code
      rows.push({ label: 'Word code', value: generateWordCode(lat, lon), mono: true });

      // Google Maps link
      rows.push({
        label: 'Maps',
        value: `<a href="https://maps.google.com/?q=${lat},${lon}" target="_blank" style="color: #4af">Open in Google Maps</a>`,
        html: true
      });

      return rows.map(r => `
        <div class="detail-row">
          <span class="detail-label">${r.label}</span>
          <span class="detail-value${r.mono ? ' mono' : ''}">${r.html ? r.value : escapeHtml(r.value)}</span>
        </div>
      `).join('');
    }

    function escapeHtml(str) {
      const div = document.createElement('div');
      div.textContent = str;
      return div.innerHTML;
    }

    // Main location fetch
    async function getLocation() {
      $('container').classList.remove('error');
      $('container').classList.add('loading');
      $('primary').textContent = 'Finding you';
      $('secondary').textContent = '';
      $('status').textContent = 'Requesting location...';
      $('actions').style.display = 'none';

      if (!navigator.geolocation) {
        showError('Geolocation not supported');
        return;
      }

      try {
        const pos = await new Promise((resolve, reject) => {
          navigator.geolocation.getCurrentPosition(resolve, reject, {
            enableHighAccuracy: true,
            timeout: 10000,
            maximumAge: 60000
          });
        });

        const { latitude: lat, longitude: lon, accuracy } = pos.coords;
        $('status').textContent = 'Looking up address...';

        const data = await reverseGeocode(lat, lon);
        locationData = { data, lat, lon, accuracy };

        const address = data.address || {};
        const primary = extractPrimary(address);
        const secondary = extractSecondary(address, primary);

        $('container').classList.remove('loading');
        $('primary').textContent = primary;
        $('secondary').textContent = secondary;
        $('status').textContent = accuracy ? `± ${Math.round(accuracy)}m` : '';
        $('actions').style.display = 'flex';
        $('detailsContent').innerHTML = buildDetails(data, lat, lon);

      } catch (err) {
        showError(err.message || 'Could not get location');
      }
    }

    function showError(msg) {
      $('container').classList.remove('loading');
      $('container').classList.add('error');
      $('primary').textContent = msg;
      $('secondary').textContent = '';
      $('status').textContent = 'Tap refresh to try again';
      $('actions').style.display = 'flex';
    }

    // Share functionality
    async function shareLocation() {
      if (!locationData) return;

      const { data, lat, lon } = locationData;
      const primary = $('primary').textContent;
      const secondary = $('secondary').textContent;
      const text = `I'm at ${primary}${secondary ? ', ' + secondary : ''}\nhttps://maps.google.com/?q=${lat},${lon}`;

      if (navigator.share) {
        try {
          await navigator.share({ text });
          return;
        } catch (e) {
          if (e.name === 'AbortError') return;
        }
      }

      // Fallback to clipboard
      try {
        await navigator.clipboard.writeText(text);
        toast('Copied to clipboard');
      } catch (e) {
        toast('Could not share');
      }
    }

    // Details panel
    function openDetails() {
      $('overlay').classList.add('open');
      $('detailsPanel').classList.add('open');
    }

    function closeDetails() {
      $('overlay').classList.remove('open');
      $('detailsPanel').classList.remove('open');
    }

    // Event listeners
    $('shareBtn').addEventListener('click', shareLocation);
    $('detailsBtn').addEventListener('click', openDetails);
    $('refreshBtn').addEventListener('click', getLocation);
    $('closeDetails').addEventListener('click', closeDetails);
    $('overlay').addEventListener('click', closeDetails);

    // Swipe down to close details
    let touchStart = 0;
    $('detailsPanel').addEventListener('touchstart', e => {
      touchStart = e.touches[0].clientY;
    });
    $('detailsPanel').addEventListener('touchmove', e => {
      const diff = e.touches[0].clientY - touchStart;
      if (diff > 50) closeDetails();
    });

    // Start
    getLocation();
  </script>
</body>
</html>
